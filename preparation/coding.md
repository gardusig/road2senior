## Practice

I recommend using LeetCode — but do it smartly (don’t grind random problems). Focus on curated lists.

## Ask Clarifying Questions

- Make sure you fully understand the problem and expected output.
- Repeat back your understanding and verify it with the interviewer.
- Be honest if you’ve seen the problem before.
- Don’t hesitate to ask “dumb” questions — better to ask than assume.
- Use examples to clarify the problem; they’ll be useful for testing later.
  - Start thinking about potential corner cases early.

## Understand the Input and Output Characteristics

- Determine the size and range of inputs and outputs.
  - This helps estimate time and space complexity.
  - Large inputs may require more optimized solutions.
- Pay attention to:
  - The length of arrays or data structures.
  - The expected size of the answer.
- Use these limits to identify constraints or patterns.

## Explore Examples and Edge Cases

- Start with small, simple examples to validate your understanding.
- Use them to sketch a basic solution and test correctness.
- Try large examples to evaluate scalability.
- Identify edge cases to ensure your solution is robust.

## Evaluate Potential Solutions

- Consider trade-offs between:
  - Correctness
  - Time complexity
  - Space complexity
  - Ease of implementation
  - Readability
- Start with a brute-force solution to establish a baseline.
  - Look for repeated operations and opportunities to optimize.
- Compare different approaches to choose the most suitable one.

## Write Clean, Readable Code

- Use descriptive variable and function names.
- Keep the structure simple and modular.
- Add comments only when necessary:
  - Clear code is better than commented spaghetti.
- Maintain proper indentation and spacing.

## Test Thoroughly

- Run your code against a variety of inputs:
  - Small inputs for sanity checks.
  - Edge cases to catch potential bugs.
- Walk through the code step-by-step for different scenarios.
  - Explain what’s happening at each stage.
